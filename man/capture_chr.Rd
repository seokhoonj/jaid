% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/capture.R
\name{capture_chr}
\alias{capture_chr}
\title{Convert expression input into a character vector}
\usage{
capture_chr(x)
}
\arguments{
\item{x}{An expression typed at the call site, e.g. \code{c(a, b)} or
\code{c("a", "b")}. Single names like \code{a} are also supported.}
}
\value{
A character vector of names.
}
\description{
Public wrapper that captures a user-supplied argument via
\code{\link[rlang:enquo]{rlang::enquo()}} and normalizes it into a character vector of names.
}
\details{
This is the \strong{user-facing helper}: it works with expressions typed
directly at the call site, such as \code{c(a, b)} (bare symbols) or
\code{c("a", "b")} (character literals).

For processing quosures or language objects \strong{as values} (not typed
directly), see the internal helpers \code{.quo_to_chr()} and \code{.lang_to_chr()}.
\itemize{
\item When used \strong{inside another function}, make sure to capture and unquote
the argument with \code{!!rlang::enquo(x)} before passing to \code{capture_chr()}.
For example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{f <- function(x) \{
  capture_chr(!!rlang::enquo(x))
\}
}\if{html}{\out{</div>}}
}
}
\examples{
\donttest{
# Character input
capture_chr(c("a", "b", "c"))

# Bare symbols
capture_chr(c(a, b, c))

# Wrappers: safe through multiple layers of NSE
f1 <- function(x) {x <- rlang::enquo(x); capture_chr(!!x)}
f2 <- function(y) {y <- rlang::enquo(y); f1(!!y)}
f3 <- function(z) {z <- rlang::enquo(z); f2(!!z)}

f1(c("a", "b", "c"))
f1(c(a, b, c))
f2(c("a", "b", "c"))
f2(c(a, b, c))
f3(c("a", "b", "c"))
f3(c(a, b, c))
}

}
\seealso{
\code{\link[rlang:enquo]{rlang::enquo()}}
}
