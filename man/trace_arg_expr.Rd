% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr.R
\name{trace_arg_expr}
\alias{trace_arg_expr}
\title{Retrieve the Original Expression Passed to an Argument}
\usage{
trace_arg_expr(
  x,
  stop_at,
  verbose = FALSE,
  skip_shiny = TRUE,
  fallback = "x",
  max_depth
)
}
\arguments{
\item{x}{An expression or object to inspect.
Should be a symbol, a call, or an evaluable expression.
Character literals (e.g., \code{"x"}) are not traceable and will return \code{"unknown"}.}

\item{stop_at}{Character vector of function names.
If a matching function name is encountered in the call stack,
the search stops and that frame's \code{x} argument is returned.
This is useful for limiting the search to a known entry point
(e.g., "assert_class") to avoid traversing unrelated frames.}

\item{verbose}{Logical; if \code{TRUE}, prints detailed inspection steps. Default is \code{FALSE}.}

\item{skip_shiny}{Logical; if \code{TRUE}, and a Shiny context is detected
(via \code{\link[=.is_shiny_running]{.is_shiny_running()}}), the function immediately returns \code{"x"}
instead of traversing the altered Shiny call stack.
This provides a safe fallback for reactive/promise environments where
the original symbol name cannot be reliably recovered.}

\item{fallback}{A character string returned when tracing fails. Default is \code{"x"}.}

\item{max_depth}{Maximum number of frames to inspect.
Optional; defaults to the current stack depth.}
}
\value{
A character string or character vector representing the original expression.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Retrieves the original expression or symbol name passed to \code{x},
similar to \code{deparse(substitute(x))}, but designed to work
through multiple layers of nested function calls.

Unlike \code{substitute()}, this function walks the call stack frame-by-frame
to reconstruct the original argument, which allows it to work even after
many nested calls or wrappers.

In \strong{Shiny reactive or promise contexts}, the altered call stack may make
exact recovery of the symbol name unreliable. This implementation improves
stability by:
\itemize{
\item Using \code{stop_at} to halt the search at a known caller function
(avoids traversing reactive internals)
\item Handling evaluation errors safely with \code{tryCatch()}
\item Preserving verbose diagnostic output without causing format errors
}

For critical Shiny logic, still treat the recovered name as \strong{best-effort}
and provide fallback behavior for ambiguous or missing results.
}
\note{
\itemize{
\item In normal R execution, \code{trace_arg_expr()} can reliably retrieve original symbol names
even after deep nesting.
\item In Shiny/reactive contexts, \code{stop_at} is \strong{strongly recommended} to improve
reproducibility and performance.
\item If no symbol is found, returns \code{NULL}.
}
}
\examples{
\donttest{
# Console
f1 <- function(a) trace_arg_expr(x = a)
f2 <- function(b) f1(b)
f3 <- function(c) f2(c)
f4 <- function(d) f3(d)
f5 <- function(e) f4(e)

trace_arg_expr(iris) # "iris"
f1(iris) # "iris"
f2(iris) # "iris"
f3(iris) # "iris"
f4(iris) # "iris"
f5(iris) # "iris"
}

\dontrun{
# Shiny
f1 <- function(a, stop_at, verbose) trace_arg_expr(x = a, stop_at = stop_at,
  verbose = verbose)
f2 <- function(b, stop_at, verbose) f1(b, stop_at, verbose)
f3 <- function(c, stop_at, verbose) f2(c, stop_at, verbose)
f4 <- function(d, stop_at, verbose) f3(d, stop_at, verbose)
f5 <- function(e, stop_at, verbose) f4(e, stop_at, verbose)
ui <- shiny::fluidPage(
  shiny::titlePanel("Test f5() for trace_arg_expr() in Shiny"),
  shiny::actionButton("run", "Run f5(iris, stop_at = 'f5', verbose = TRUE)"),
  shiny::verbatimTextOutput("output")
)

server <- function(input, output) {
  result <- shiny::reactiveVal("")

  shiny::observeEvent(input$run, {
    res <- utils::capture.output({
      out <- f5(iris, stop_at = "f5", verbose = TRUE)
      cat(sprintf("Result from f5: '\%s'\n", out))
    })
    result(paste(res, collapse = "\n"))
  })

  output$output <- shiny::renderText(result())
}

shiny::shinyApp(ui, server)

# Exception
f1 <- function(a, stop_at, verbose) trace_arg_expr(x = a, stop_at = stop_at,
  verbose = verbose)
f2 <- function(b, stop_at, verbose) f1(b, stop_at, verbose)
f3 <- function(c, stop_at, verbose) f2(c, stop_at, verbose)
f4 <- function(d, stop_at, verbose) f3(d, stop_at, verbose)
f5 <- function(e, stop_at, verbose) f4(e, stop_at, verbose)

trace_arg_expr("x") # "x"
do.call("trace_arg_expr", list(x = iris)) # "x"
do.call(trace_arg_expr, list(x = iris)) # "x"
do.call("f5", list(e = iris, stop_at = "f5", verbose = FALSE)) # "e" - bad
do.call(f5, list(e = iris, stop_at = "f5", verbose = FALSE)) # "x"
rlang::exec("trace_arg_expr", x = iris) # "x"
rlang::exec(trace_arg_expr, x = iris) # "x"
rlang::exec("f5", e = iris, stop_at = "f5", verbose = FALSE) # "e" - bad
rlang::exec(f5, e = iris, stop_at = "f5", verbose = FALSE) # "x"
}

}
