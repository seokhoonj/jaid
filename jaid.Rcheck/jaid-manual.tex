\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\makeatletter\@ifl@t@r\fmtversion{2018/04/01}{}{\usepackage[utf8]{inputenc}}\makeatother
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `jaid'}}
\par\bigskip{\large \today}
\end{center}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {jaid: Joo's functional aid toolkit}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {seokhoon Joo}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Joo's functional aid toolkit}
\item[Version]\AsIs{0.0.0.9000}
\item[Description]\AsIs{Joo's functional aid toolkit for efficient and productive programming.}
\item[License]\AsIs{MIT + file LICENSE}
\item[Encoding]\AsIs{UTF-8}
\item[Depends]\AsIs{R (>= 4.1.0)}
\item[Imports]\AsIs{Rcpp (>= 0.12.10), cli (>= 3.6.3), data.table (>= 1.13.0),
grDevices (>= 4.2.3), grid (>= 4.2.3), kableExtra (>= 1.4.0),
methods (>= 4.2.3), openssl (>= 1.4.1), openxlsx (>= 4.2.3),
png (>= 0.1.8), readxl (>= 1.4.2), reticulate (>= 1.40.0),
rlang (>= 1.1.1), scales (>= 1.3.0), stringi (>= 1.7.6),
stringr (>= 1.4.0), tibble (>= 3.2.1), usethis (>= 2.1.6)}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.2}
\item[LinkingTo]\AsIs{Rcpp}
\item[Suggests]\AsIs{pryr (>= 0.1.6)}
\item[Config/testthat/edition]\AsIs{3}
\item[NeedsCompilation]\AsIs{yes}
\item[Author]\AsIs{seokhoon Joo [aut, cre]}
\item[Maintainer]\AsIs{seokhoon Joo }\email{seokhoonj@gmail.com}\AsIs{}
\end{description}
\Rdcontents{Contents}
\HeaderA{jaid-package}{jaid: Joo's functional aid toolkit}{jaid.Rdash.package}
\aliasA{jaid}{jaid-package}{jaid}
\keyword{internal}{jaid-package}
%
\begin{Description}
Joo's functional aid toolkit for efficient programming.
\end{Description}
%
\begin{Author}
\strong{Maintainer}: seokhoon Joo \email{seokhoonj@gmail.com}

\end{Author}
\HeaderA{add\_mon}{Add months}{add.Rul.mon}
%
\begin{Description}
Add months to the date.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
add_mon(date, mon)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{date}] A date

\item[\code{mon}] A number of months to be added
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A date
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# add months

date <- Sys.Date()
add_mon(date, 3)

\end{ExampleCode}
\end{Examples}
\HeaderA{add\_year}{Add years}{add.Rul.year}
%
\begin{Description}
Add years to the date.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
add_year(date, year)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{date}] A date

\item[\code{year}] A number of years to be added
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A date
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# add years

date <- Sys.Date()
add_year(date, 3)

\end{ExampleCode}
\end{Examples}
\HeaderA{as\_comma}{As comma applied label}{as.Rul.comma}
%
\begin{Description}
Convert a numeric vector to a comma applied string vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
as_comma(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# convert to a comma applied string vector
as_comma(c(123456, 234567))

\end{ExampleCode}
\end{Examples}
\HeaderA{as\_numeric}{As functions}{as.Rul.numeric}
\aliasA{as\_character}{as\_numeric}{as.Rul.character}
\aliasA{as\_double}{as\_numeric}{as.Rul.double}
\aliasA{as\_integer}{as\_numeric}{as.Rul.integer}
\aliasA{as\_logical}{as\_numeric}{as.Rul.logical}
%
\begin{Description}
As logical, integer, numeric, character maintaining the original shape.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
as_numeric(x)

as_logical(x)

as_integer(x)

as_double(x)

as_character(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a vector or matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a converted vector or matrix
\end{Value}
\HeaderA{assert\_class}{Assert class}{assert.Rul.class}
%
\begin{Description}
Assert object class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
assert_class(obj, class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{obj}] an object

\item[\code{class}] an object class
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# assert object class
assert_class(cars, "data.frame")

\end{ExampleCode}
\end{Examples}
\HeaderA{bmonth}{Beginning of the month, End of the month}{bmonth}
\aliasA{emonth}{bmonth}{emonth}
%
\begin{Description}
Get the beginning of the month.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bmonth(date)

emonth(date)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{date}] A date
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A date
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# the beginning of the month

bmonth(Sys.Date())

# the end of the month

emonth(Sys.Date())

\end{ExampleCode}
\end{Examples}
\HeaderA{check\_col\_spec}{Check Column Specification Against a Data Frame}{check.Rul.col.Rul.spec}
%
\begin{Description}
Validates whether the columns in a given data frame match an expected
column specification. The specification includes expected column names
and their corresponding classes. The function returns a \code{data.table}
with the actual and expected classes, along with a status indicating
whether each column matches, is missing, or is extra.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_col_spec(df, col_spec)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] A \code{data.frame} or \code{data.table} containing the data to be checked.

\item[\code{col\_spec}] A named \code{list} defining the expected specification.
Each name corresponds to a column, and each value is the expected class.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.table} with the following columns:
\begin{itemize}

\item{} \code{column}: Column name
\item{} \code{actual}: Actual class of the column (NA if missing)
\item{} \code{expected}: Expected class of the column (NA if not specified)
\item{} \code{status}: Comparison result: "match", "mismatch", "missing", or "extra"

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

df <- data.frame(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie"),
  age = c(25, 30, 28),
  paid = c(TRUE, FALSE, TRUE)
)

col_spec <- list(
  id = "character",
  name = "character",
  age = "integer",
  premium = "numeric"
)

check_col_spec(df, col_spec)

\end{ExampleCode}
\end{Examples}
\HeaderA{col\_diff}{Column diffrences}{col.Rul.diff}
%
\begin{Description}
Column diffrences for a numeric matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
col_diff(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric matrix
\end{Value}
\HeaderA{col\_max}{max, min, sum on each column of a matrix}{col.Rul.max}
\aliasA{col\_min}{col\_max}{col.Rul.min}
\aliasA{col\_sum}{col\_max}{col.Rul.sum}
%
\begin{Description}
Get max, min, sum of values on each column of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
col_max(x)

col_min(x)

col_sum(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of min, max, sum of values on each column of a matrix
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# column max
x <- matrix(c(1:9), ncol = 3)
col_max(x)

# column min
x <- matrix(c(1:9), ncol = 3)
col_min(x)

# column sum
x <- matrix(c(1:9), ncol = 3)
col_sum(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{combine\_overlapping\_date\_range}{Combine overlapping date ranges}{combine.Rul.overlapping.Rul.date.Rul.range}
%
\begin{Description}
Combine multiple overlapping date ranges.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
combine_overlapping_date_range(
  df,
  id_var,
  merge_var,
  from_var,
  to_var,
  interval = 0,
  collapse = "|"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame with data ranges

\item[\code{id\_var}] id column names

\item[\code{merge\_var}] column names to be collapsed

\item[\code{from\_var}] a column name of start date

\item[\code{to\_var}] a column name of end date

\item[\code{interval}] an interval of previous end date to next start date to be combined

\item[\code{collapse}] an optional character string to seperate the result of \code{merge\_var}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{data.frame} with no overlapping date ranges.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# combine overlapping date ranges
## Not run: 
id <- c("A", "A", "B")
work <- c("cleansing", "analysis", "cleansing")
sdate <- as.Date(c("2022-03-01", "2022-03-05", "2022-03-08"))
edate <- as.Date(c("2022-03-06", "2022-03-09", "2022-03-10"))
df <- data.table::data.table(id = id, work = work, sdate = sdate, edate = edate)
combine_overlapping_date_range(df, id, work, sdate, edate, interval = 0)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{count\_pattern}{Count pattern matched strings}{count.Rul.pattern}
%
\begin{Description}
Count pattern matched strings from a string vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
count_pattern(pattern, x, ignore.case = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pattern}] a string containing a \LinkA{regular expression}{regular expression}

\item[\code{x}] a string

\item[\code{ignore.case}] if \code{FALSE}, the pattern matching is case sensitive and if \code{TRUE}, case is ignored during matching.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# count pattern matched strings from a string vector
count_pattern(pattern = "c", c("a|b|c", "a|c|c"))

\end{ExampleCode}
\end{Examples}
\HeaderA{create\_library\_r}{Create library.R}{create.Rul.library.Rul.r}
%
\begin{Description}
Create library.R file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
create_library_r(path = "library.R")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] a string value specifying the path of the file.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# create library.R file
## Not run: create_library_r()

\end{ExampleCode}
\end{Examples}
\HeaderA{data\_xlsx}{Write data in an excel file}{data.Rul.xlsx}
%
\begin{Description}
Write data in an excel file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data_xlsx(data, file, rc = c(1L, 1L), rowNames = FALSE, overwrite = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] A data frame

\item[\code{file}] A file path

\item[\code{rc}] A vector of starting point row and column, default c(1L, 1L)

\item[\code{rowNames}] A boolean value contains row names or not

\item[\code{overwrite}] A boolean value that overwrite or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# write xlsx file
## Not run: 
write_xlsx(list(cars = cars, matcars = mtcars), "data.xlsx")
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{del\_pattern}{Delete patterns}{del.Rul.pattern}
%
\begin{Description}
Delete patterns from a string vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
del_pattern(pattern, x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pattern}] a string containing a \LinkA{regular expression}{regular expression}

\item[\code{x}] a string vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# delete patterns from a string vector
del_pattern(pattern = "c", c("abc", "acc"))

\end{ExampleCode}
\end{Examples}
\HeaderA{del\_ptr}{Delete external pointer}{del.Rul.ptr}
%
\begin{Description}
Delete external pointer
\end{Description}
%
\begin{Usage}
\begin{verbatim}
del_ptr(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No return value.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# delete pointer
df <- data.frame(x = c(1:3), y = c("a", "b", "c"))
data.table::setalloccol(df)
get_ptr(df)
del_ptr(df)
get_ptr(df) # NULL

\end{ExampleCode}
\end{Examples}
\HeaderA{desub}{Desub}{desub}
\aliasA{desubs}{desub}{desubs}
%
\begin{Description}
This function operates like \code{deparse(substitute(x))} inside the functions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
desub(x)

desubs(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] an expression that can be a string vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# desub
f1 <- function(a) desub(a)
f2 <- function(b) f1(b)
f3 <- function(c) f2(c)
f4 <- function(d) f3(d)
f5 <- function(e) f4(e)
desub(iris) # iris
f1(iris) # iris
f2(iris) # iris
f3(iris) # iris
f4(iris) # iris
f5(iris) # iris

# desubs
f1 <- function(a) desubs(a)
f2 <- function(b) f1(b)
f3 <- function(c) f2(c)
f4 <- function(d) f3(d)
f5 <- function(e) f4(e)
desubs(c(iris, cars)) # "c" "iris" "cars"
f1(c(iris, cars)) # "c" "iris" "cars"
f2(c(iris, cars)) # "c" "iris" "cars"
f3(c(iris, cars)) # "c" "iris" "cars"
f4(c(iris, cars)) # "c" "iris" "cars"
f5(c(iris, cars)) # "c" "iris" "cars"

\end{ExampleCode}
\end{Examples}
\HeaderA{diff\_cols}{Different columns}{diff.Rul.cols}
%
\begin{Description}
Columns that the data frame does not contain
\end{Description}
%
\begin{Usage}
\begin{verbatim}
diff_cols(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# different columns
diff_cols(mtcars, c("mpg", "cyl", "disp", "hp", "drat"))

\end{ExampleCode}
\end{Examples}
\HeaderA{dolock}{dolock, unlock}{dolock}
\aliasA{unlock}{dolock}{unlock}
%
\begin{Description}
lock and unlock data files for security.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dolock(obj, key)

unlock(obj, key)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{obj}] An object to save

\item[\code{key}] A string specifying password
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## dolock
## Not run: dolock("your data", "your password")

## unlock
## Not run: unlock("your data", "your password")

\end{ExampleCode}
\end{Examples}
\HeaderA{draw\_line}{Draw a line}{draw.Rul.line}
%
\begin{Description}
Draw a line in console.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
draw_line(width, mark = "=")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{width}] a numeric vector specifying width (default: \code{getOption("width")})

\item[\code{mark}] a string specifying mark (default: "=")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector with repeated mark
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
cat(draw_line())

\end{ExampleCode}
\end{Examples}
\HeaderA{equal}{Equal columns of two data frames.}{equal}
%
\begin{Description}
Whether the columns of two data frames are equal.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
equal(x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}, \code{y}] two data frames
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Are the columns of two data frames equal?
equal(mtcars, mtcars)

\end{ExampleCode}
\end{Examples}
\HeaderA{fill\_one\_before\_first\_one}{Fill with one before the first one}{fill.Rul.one.Rul.before.Rul.first.Rul.one}
\aliasA{set\_one\_before\_first\_one}{fill\_one\_before\_first\_one}{set.Rul.one.Rul.before.Rul.first.Rul.one}
%
\begin{Description}
Fill with one before the first one appears in each column in a binary matrix
by rownames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fill_one_before_first_one(x)

set_one_before_first_one(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A binary matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A binary matrix
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# fill with one before the first one appears by rownames
x <- matrix(c(0, 1, 0, 0, 0, 1, 1, 0, 1), nrow = 3)
set_rownames(x, c(1, 1, 2))
fill_one_before_first_one(x)

# Set to one before the first one appears by rownames
x <- matrix(c(0, 1, 0, 0, 0, 1, 1, 0, 1), nrow = 3)
set_rownames(x, c(1, 1, 2))
fill_one_before_first_one(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{fill\_zero\_not\_first\_pos}{Fill with or set to zero except for the first positive values}{fill.Rul.zero.Rul.not.Rul.first.Rul.pos}
\aliasA{set\_zero\_not\_first\_pos}{fill\_zero\_not\_first\_pos}{set.Rul.zero.Rul.not.Rul.first.Rul.pos}
%
\begin{Description}
Fill with or set to zero except for the first positive values of a numerical
matrix by rownames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fill_zero_not_first_pos(x, cols)

set_zero_not_first_pos(x, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numerical matrix

\item[\code{cols}] A boolean vector. for example, if you want select first and third
columns for 3 X 3 matrix, c(1, 0, 1).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix with only first positive value for each row names, and the
other values become 0.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# fill with zero except for the first positive values of a numerical matrix
# by rownames
x <- matrix(c(-1, 2, 0, -2, -1, 5, 2, -2, 3), nrow = 3)
set_rownames(x, c(1, 1, 2))
fill_zero_not_first_pos(x)

# set to zero except for the first positive values of a numerical matrix by
# rownames
x <- matrix(c(-1, 2, 0, -2, -1, 5, 2, -2, 3), nrow = 3)
set_rownames(x, c(1, 1, 2))
set_zero_not_first_pos(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_copied\_dt}{Get a copied data.table}{get.Rul.copied.Rul.dt}
%
\begin{Description}
Get a copied data.table.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_copied_dt(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a copied data.table
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get copied data.table
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
get_copied_dt(df)

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_japanese\_cols}{Get japanese columns?}{get.Rul.japanese.Rul.cols}
%
\begin{Description}
Get japanese columns?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_japanese_cols(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a data frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
japanese column names
\end{Value}
\HeaderA{get\_pattern}{Get a first pattern}{get.Rul.pattern}
%
\begin{Description}
Get a first pattern from a string vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_pattern(pattern, x, ignore.case = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pattern}] a string containing a \LinkA{regular expression}{regular expression}

\item[\code{x}] a string vector

\item[\code{ignore.case}] if \code{FALSE}, the pattern matching is case sensitive and if \code{TRUE}, case is ignored during matching.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get a first pattern from a string vector
get_pattern(pattern = "c", c("a|b|c", "a|c|c"))

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_pattern\_all}{Get all patterns}{get.Rul.pattern.Rul.all}
%
\begin{Description}
Get all patterns from a string vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_pattern_all(pattern, x, collapse = "|", ignore.case = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pattern}] a string containing a \LinkA{regular expression}{regular expression}

\item[\code{x}] a string vector

\item[\code{collapse}] an optional character string to separate the results. Not
\code{\LinkA{NA\_character\_}{NA.Rul.character.Rul.}}. When \code{collapse} is a string, the result is always a string
(\code{\LinkA{character}{character}} of length 1). default "|"

\item[\code{ignore.case}] if \code{FALSE}, the pattern matching is case sensitive and if \code{TRUE}, case is ignored during matching.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get all patterns from a string vector
get_pattern_all(pattern = "c", c("a|b|c", "a|c|c"))

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_prop}{Get proportion from a vector}{get.Rul.prop}
%
\begin{Description}
Get proportion from a vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_prop(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a proportion data.frame
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
get_prop(sample(1:10, 1000, replace = TRUE))
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_ptr}{Get external pointer}{get.Rul.ptr}
%
\begin{Description}
Get external pointer
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_ptr(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No return value.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get pointer
## Not run: 
df <- data.frame(x = c(1:3), y = c("a", "b", "c"))
get_ptr(df)
df <- setalloccol(df)
get_ptr(df)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_stat\_by}{Get statistic by groups}{get.Rul.stat.Rul.by}
%
\begin{Description}
Get statistic column by groups
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_stat_by(df, group_var, value_var, fun = sum)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{group\_var}] names of columns for grouping

\item[\code{value\_var}] names of columns to be applied for statistics.

\item[\code{fun}] a function applying to columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a grouped data.frame
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get statistics by groups
## Not run: 
set_ptr(mtcars)
get_stat_by(mtcars, .(cyl, vs), value_var = .(hp, drat), fun = sum)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{grepl\_and}{grepl with \code{And} conditions}{grepl.Rul.and}
%
\begin{Description}
grepl with \code{And} conditions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grepl_and(pattern, x, ignore.case = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pattern}] a character vector containing regular expressions

\item[\code{x}] a character vector

\item[\code{ignore.case}] if \code{FALSE}, the pattern matching is case sensitive and
if \code{TRUE}, case is ignored during matching.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a boolean vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# grepl with "And" conditions
string <- "abcde12345"
grepl_and(c("a", "c", "e"), string)
grepl_and(c("a", "c", "[1-5]"), string)
grepl_and(c("a", "c", "z"), string)

\end{ExampleCode}
\end{Examples}
\HeaderA{has\_attr}{Has attributes}{has.Rul.attr}
%
\begin{Description}
Whether the data has specific attributes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
has_attr(df, attr, error_raise = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{attr}] attribute names

\item[\code{error\_raise}] a logical whether to raise an error or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# has attributes
has_attr(mtcars, c("names", "class"))

\end{ExampleCode}
\end{Examples}
\HeaderA{has\_cols}{Has columns}{has.Rul.cols}
%
\begin{Description}
Whether the data has specific columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
has_cols(df, cols, error_raise = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] column names

\item[\code{error\_raise}] a logical whether to raise an error or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# has columns
has_cols(mtcars, c("cyl", "disp"))

# raise an error
## Not run: 
has_cols(mtcars, c("cyl", "iris"), error_raise = TRUE)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{has\_len}{Has a length}{has.Rul.len}
%
\begin{Description}
Whether the object has a length or not
\end{Description}
%
\begin{Usage}
\begin{verbatim}
has_len(x, error_raise = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a

\item[\code{error\_raise}] a logical whether to raise an error or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# has a length
has_len(c(numeric(), character()))

# raise an error
## Not run: 
has_len(c(numeric(), character()), error_raise = TRUE)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{has\_ptr}{Has not a null pointer?}{has.Rul.ptr}
%
\begin{Description}
Has not a null external pointer?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
has_ptr(df, error_raise = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{error\_raise}] a logcial whether to raise an error or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value whether to have not a null external pointer or not
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Has not null external pointer?
has_ptr(iris, error_raise = FALSE)

\end{ExampleCode}
\end{Examples}
\HeaderA{has\_rows}{Has rows}{has.Rul.rows}
%
\begin{Description}
Whether the data has rows
\end{Description}
%
\begin{Usage}
\begin{verbatim}
has_rows(df, error_raise = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{error\_raise}] a logcial whether to raise an error or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# has rows
## Not run: 
df <- data.frame()
has_rows(df)
## End(Not run)

# raise an error
## Not run: 
df <- data.frame()
has_rows(df, error_raise = TRUE)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{i64\_to\_num}{Integer64 to numeric}{i64.Rul.to.Rul.num}
%
\begin{Description}
Change class from \code{integer64} to \code{numeric} for a \code{data.frame}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
i64_to_num(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a \code{data.frame}
\end{ldescription}
\end{Arguments}
\HeaderA{icol}{order numbers of columns}{icol}
%
\begin{Description}
Get order numbers of columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
icol(x, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a data.frame

\item[\code{cols}] string names of columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
order numbers of columns
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# order numbers of columns
icol(mtcars, c("disp", "drat", "qsec", "am", "carb"))

\end{ExampleCode}
\end{Examples}
\HeaderA{image\_xlsx}{Insert images in an excel file}{image.Rul.xlsx}
%
\begin{Description}
Insert images in an excel file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
image_xlsx(
  images,
  file,
  rc = c(1L, 1L),
  width = 12,
  height = 6,
  dpi = 300,
  overwrite = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{images}] image file paths

\item[\code{file}] a file path

\item[\code{rc}] a vector of starting point row and column, default c(1L, 1L)

\item[\code{width}] image width

\item[\code{height}] image height

\item[\code{dpi}] image resolution

\item[\code{overwrite}] A boolean value that overwrite or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# insert images in an excel file
## Not run: 
image_xlsx(list(image1, image2), "image.xlsx")
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{is.null.externalptr}{Is a null external pointer?}{is.null.externalptr}
%
\begin{Description}
Is a null external pointer?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
is.null.externalptr(pointer)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pointer}] an externalptr object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical value whether it is null external pointer or not.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# is null external pointer?
## Not run: 
p <- new("externalptr")
is.null.externalptr(p)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{is\_date\_format}{Is a date format?}{is.Rul.date.Rul.format}
%
\begin{Description}
Is a date or date format vector?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
is_date_format(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] value to check
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a logical whether it's a date format or not.
\end{Value}
\HeaderA{is\_japanese}{Is the text japanese?}{is.Rul.japanese}
%
\begin{Description}
Is the text japanese?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
is_japanese(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a boolean vector
\end{Value}
\HeaderA{match\_attr}{Matched attributes}{match.Rul.attr}
%
\begin{Description}
Find matched attributes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
match_attr(x, name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any objects; e.g, list, columns of a data.frame or data.table

\item[\code{name}] the character attribute names.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
matched attributes' names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# matched attributes
match_attr(iris, c("class", "names"))

\end{ExampleCode}
\end{Examples}
\HeaderA{match\_cols}{Match columns}{match.Rul.cols}
%
\begin{Description}
Get matched columns from a data frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
match_cols(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# match columns
df <- data.frame(x = c(1, 2, 3), y = c("A", "B", "C"), z = c(4, 5, 6))
match_cols(df, c("x", "z"))

\end{ExampleCode}
\end{Examples}
\HeaderA{matXcol}{Matrix X Column vector}{matXcol}
%
\begin{Description}
Multiply a matrix and a column vector and allocate the result to the matrix memory.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matXcol(mat, vec)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a numeric matrix

\item[\code{vec}] a numeric vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
\HeaderA{matXmat}{Matrix X Matrix}{matXmat}
%
\begin{Description}
Multiply matrices and allocate the result to a first matrix memory.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matXmat(x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric matrix

\item[\code{y}] a numeric matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
\HeaderA{matXnum}{Matrix X Number}{matXnum}
%
\begin{Description}
Multiply a matrix and a numeric value and allocate the result to the matrix memory.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matXnum(mat, num)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a numeric matrix

\item[\code{num}] a numeric value
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
\HeaderA{matXrow}{Matrix X Row vector}{matXrow}
%
\begin{Description}
Multiply a matrix and a row vector and allocate the result to the matrix memory.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
matXrow(mat, vec)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a numeric matrix

\item[\code{vec}] a numeric vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
\HeaderA{max\_by\_colnames}{max, min, sum by column names}{max.Rul.by.Rul.colnames}
\aliasA{min\_by\_colnames}{max\_by\_colnames}{min.Rul.by.Rul.colnames}
\aliasA{sum\_by\_colnames}{max\_by\_colnames}{sum.Rul.by.Rul.colnames}
%
\begin{Description}
max, min, sum of values on each column name of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
max_by_colnames(x, na.rm = TRUE)

min_by_colnames(x, na.rm = TRUE)

sum_by_colnames(x, na.rm = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric matrix

\item[\code{na.rm}] a boolean value removing NA or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of minimum values shrinked by column names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# max by col nm
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
max_by_colnames(x)

# min by col nm
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
min_by_colnames(x)

# sum by col nm
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
sum_by_colnames(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{max\_by\_dimnames}{max, min, sum by dim (row and column) names}{max.Rul.by.Rul.dimnames}
\aliasA{min\_by\_dimnames}{max\_by\_dimnames}{min.Rul.by.Rul.dimnames}
\aliasA{sum\_by\_dimnames}{max\_by\_dimnames}{sum.Rul.by.Rul.dimnames}
%
\begin{Description}
max, min, sum of values on each dim (row and column) name of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
max_by_dimnames(x, na.rm = TRUE)

min_by_dimnames(x, na.rm = TRUE)

sum_by_dimnames(x, na.rm = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric matrix

\item[\code{na.rm}] a boolean value removing NA or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of minimum values shrinked by dim (row and column) names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# max by dim names
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
max_by_dimnames(x)

# min by dim names
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
min_by_dimnames(x)

# sum by dim names
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
sum_by_dimnames(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{max\_by\_rownames}{max, min, sum by row names}{max.Rul.by.Rul.rownames}
\aliasA{min\_by\_rownames}{max\_by\_rownames}{min.Rul.by.Rul.rownames}
\aliasA{sum\_by\_rownames}{max\_by\_rownames}{sum.Rul.by.Rul.rownames}
%
\begin{Description}
max, min, sum of values on each row name of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
max_by_rownames(x, na.rm = TRUE)

min_by_rownames(x, na.rm = TRUE)

sum_by_rownames(x, na.rm = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric matrix

\item[\code{na.rm}] a boolean value removing NA or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of minimum values shrinked by row names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# max by row nm
x <- matrix(c(1:9), nrow = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
max_by_rownames(x)

# min by row nm
x <- matrix(c(1:9), nrow = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
min_by_rownames(x)

# sum by row nm
x <- matrix(c(1:9), nrow = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))
sum_by_rownames(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{meta}{Meta information}{meta}
%
\begin{Description}
Show meta information
\end{Description}
%
\begin{Usage}
\begin{verbatim}
meta(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] object vector, data.frame, environment and etc
\end{ldescription}
\end{Arguments}
%
\begin{Value}
meta information data frame
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
meta(cars)

\end{ExampleCode}
\end{Examples}
\HeaderA{mkdir}{mkdir}{mkdir}
%
\begin{Description}
Same function of linux mkdir command
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mkdir(
  folders = c("dev", "data", "info", "inst", "output", "R", "raw", "report", "rules")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folders}] A string vector specifying folder names
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return, this function makes folders. if the folders already exist,
no effect
\end{Value}
\HeaderA{mondiff}{Month difference}{mondiff}
%
\begin{Description}
Month difference between two dates
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mondiff(sdate, edate, day_limit = c(0:31))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sdate}] a start date vector

\item[\code{edate}] a end date vector

\item[\code{day\_limit}] if the day of sdate is less than \code{day\_limit}, count it as a
full month, if the day of edate is greater than or equal to \code{day\_limit},
count it as a full month.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# mondiff
sdate <- as.Date("1999-12-31")
edate <- as.Date("2000-01-01")
mondiff(sdate, edate)

\end{ExampleCode}
\end{Examples}
\HeaderA{mostfreq}{Most frequent value (mode, modal value)}{mostfreq}
%
\begin{Description}
Get the most frequent value.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mostfreq(x, na.rm = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector

\item[\code{na.rm}] A boolean value removing na or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the most frequent value vector and its frequency
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get the most frequent values
x <- c(1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5)
mostfreq(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{paste\_comma}{Paste comma}{paste.Rul.comma}
%
\begin{Description}
Paste vector elements with commas.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
paste_comma(x, newline = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a vector

\item[\code{newline}] a logical whether to add newlines by each element
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
# paste comma
paste_comma(names(mtcars))

\end{ExampleCode}
\end{Examples}
\HeaderA{paste\_list}{Paste vectors of a list}{paste.Rul.list}
%
\begin{Description}
Paste vectors of equal length in a list or data.frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
paste_list(x, sep = "|", na.rm = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a list with same length vectors or data frame column vectors you want to paste.

\item[\code{sep}] a character string to separate the terms.

\item[\code{na.rm}] a logical evaluating to TRUE or FALSE indicating whether NA values should be stripped before the computation proceeds.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector pasted
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# paste length and width of iris
iris$size <- paste_list(iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")])
head(iris)

\end{ExampleCode}
\end{Examples}
\HeaderA{paste\_sort\_uni\_str}{Paste sorted unique strings}{paste.Rul.sort.Rul.uni.Rul.str}
%
\begin{Description}
Paste sorted unique strings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
paste_sort_uni_str(x, collapse = "|")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector

\item[\code{collapse}] an optional character string to separate the results. Not
\code{\LinkA{NA\_character\_}{NA.Rul.character.Rul.}}. When \code{collapse} is a string, the result is always a string
(\code{\LinkA{character}{character}} of length 1). default "|"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# paste sorted unique string
paste_sort_uni_str(c("a", "a", "c", "b", "b", "d", "e"))

\end{ExampleCode}
\end{Examples}
\HeaderA{paste\_str}{Paste strings}{paste.Rul.str}
%
\begin{Description}
Paste strings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
paste_str(x, collapse = "|")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector

\item[\code{collapse}] an optional character string to separate the results. Not
\code{\LinkA{NA\_character\_}{NA.Rul.character.Rul.}}. When \code{collapse} is a string, the result is always a string
(\code{\LinkA{character}{character}} of length 1). default "|"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# paste string
paste_str(c("a", "b", "c"))

\end{ExampleCode}
\end{Examples}
\HeaderA{paste\_uni\_str}{Paste unique strings}{paste.Rul.uni.Rul.str}
%
\begin{Description}
Paste unique strings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
paste_uni_str(x, collapse = "|")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector

\item[\code{collapse}] an optional character string to separate the results. Not
\code{\LinkA{NA\_character\_}{NA.Rul.character.Rul.}}. When \code{collapse} is a string, the result is always a string
(\code{\LinkA{character}{character}} of length 1). default "|"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# paste unique string
paste_uni_str(c("a", "a", "c", "b", "b", "d", "e"))

\end{ExampleCode}
\end{Examples}
\HeaderA{plot\_data\_image}{Plot a data image}{plot.Rul.data.Rul.image}
%
\begin{Description}
Plot a data image (html < png < Plots in RStudio).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_data_image(
  data,
  caption = "Table.1",
  footnote = NULL,
  digits = 2,
  full_width = FALSE,
  html_font = "Comic Sans MS",
  zoom = 1.5,
  width = NULL,
  height = 0.5
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame

\item[\code{caption}] The table caption.

\item[\code{footnote}] A vector of footnote texts, Footnotes here will be labeled with special symbols.
The vector here should not have more than 20 elements.

\item[\code{digits}] Maximum number of digits for numeric columns, passed to round(). This can also be a vector of length ncol(x), to set the
number of digits for individual columns.

\item[\code{full\_width}] A TRUE or FALSE variable controlling whether the HTML table should have the preferable format for
\code{full\_width}. If not specified, a HTML table will have full width by default but this option will be set to \code{FALSE} for a LaTeX table

\item[\code{html\_font}] A string for HTML css font.

\item[\code{zoom}] A number specifying the zoom factor. A zoom factor of 2 will result in twice as many pixels vertically and horizontally. Note that
using 2 is not exactly the same as taking a screenshot on a HiDPI (Retina) device: it is like increasing the zoom to 200 doubling the
height and width of the browser window. This differs from using a HiDPI device because some web pages load different, higher-
resolution images when they know they will be displayed on a HiDPI device (but using zoom will not report that there is a HiDPI
device).

\item[\code{width}] A numeric vector or unit object specifying width.

\item[\code{height}] A numeric vector or unit object specifying height.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# plot a data image
## Not run: 
plot_data_image(head(data), height = .5)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{plot\_xlsx}{Draw plots in an excel file}{plot.Rul.xlsx}
%
\begin{Description}
Draw plots in an excel file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_xlsx(
  plots,
  file,
  rc = c(1L, 1L),
  width = 12,
  height = 6,
  dpi = 300,
  overwrite = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{plots}] ggplot files

\item[\code{file}] a file path

\item[\code{rc}] a vector of starting point row and column, default c(1L, 1L)

\item[\code{width}] image width

\item[\code{height}] image height

\item[\code{dpi}] image resolution

\item[\code{overwrite}] A boolean value that overwrite or not
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# draw ggplot objects in an excel file
## Not run: 
draw_xlsx(list(image1, image2), "image.xlsx")
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{quote\_comma}{Quote and paste comma}{quote.Rul.comma}
%
\begin{Description}
Quote vector elements and paste it with commas.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
quote_comma(..., newline = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] an expressions with no quotations

\item[\code{newline}] a logical whether to add newlines by each element
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
# quote comma
quote_comma(mpg, cyl, disp, hp, drat)

\end{ExampleCode}
\end{Examples}
\HeaderA{random\_sampling}{Random sampling}{random.Rul.sampling}
%
\begin{Description}
Random sampling for a \code{data.frame} or a vector
\end{Description}
%
\begin{Usage}
\begin{verbatim}
random_sampling(x, size, replace = TRUE, prob = NULL, seed = 123)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] either a \code{data.frame} or a vector

\item[\code{size}] a non-negative integer giving the number of items to choose.

\item[\code{replace}] should sampling be with replacement?

\item[\code{prob}] a vector of probability weights for obtaining the elements of the vector being sampled.

\item[\code{seed}] a single value, interpreted as an integer, or NULL.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
either a \code{data.frame} or a vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
random_sampling(iris)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{rands}{Rands}{rands}
%
\begin{Description}
Generate a sample matrix with specific numbers randomly
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rands(dim, x = c(0L, 1L), replace = TRUE, prob = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dim}] a numeric vector specifying dimensions

\item[\code{x}] a numeric vector specifying numbers

\item[\code{replace}] should sampling be with replacement?

\item[\code{prob}] a vector of probability weights for obtaining the elements of the vector being sampled.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with specific numbers
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# rands
rands(c(5, 5))

\end{ExampleCode}
\end{Examples}
\HeaderA{read\_rds}{read\_rds}{read.Rul.rds}
%
\begin{Description}
read\_rds is almost same as readRDS except for a pointer.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
read_rds(file, refhook = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{file}] a \LinkA{connection}{connection} or the name of the file where the R object is saved
to or read from.

\item[\code{refhook}] a hook function for handling reference objects.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
an \R{} object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# compare pointer values
## Not run: data <- copy(women)
data.table::setDT(data)
saveRDS(data, "data.rds")
df <- readRDS("data.rds")
dt <- read_rds("data.rds")
attributes(df)$.internal.selfref # <pointer: (nil)>
attributes(dt)$.internal.selfref
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{read\_wb}{read\_wb}{read.Rul.wb}
%
\begin{Description}
read\_wb is almost same as \code{\LinkA{openxlsx::readWorkbook()}{openxlsx::readWorkbook()}} but it's convenient when not knowing the
sheet names. and the output type is a data.table not a tibble.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
read_wb(
  xlsxFile,
  sheet = NULL,
  startRow = 1,
  colNames = TRUE,
  rowNames = FALSE,
  detectDates = FALSE,
  skipEmptyRows = TRUE,
  skipEmptyCols = TRUE,
  rows = NULL,
  cols = NULL,
  check.names = FALSE,
  sep.names = ".",
  namedRegion = NULL,
  na.strings = "NA",
  fillMergedCells = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{xlsxFile}] An xlsx file, Workbook object or URL to xlsx file.

\item[\code{sheet}] The name or index of the sheet to read data from.

\item[\code{startRow}] first row to begin looking for data.  Empty rows at the top of a file are always skipped,
regardless of the value of startRow.

\item[\code{colNames}] If \code{TRUE}, the first row of data will be used as column names.

\item[\code{rowNames}] If \code{TRUE}, first column of data will be used as row names.

\item[\code{detectDates}] If \code{TRUE}, attempt to recognise dates and perform conversion.

\item[\code{skipEmptyRows}] If \code{TRUE}, empty rows are skipped else empty rows after the first row containing data
will return a row of NAs.

\item[\code{skipEmptyCols}] If \code{TRUE}, empty columns are skipped.

\item[\code{rows}] A numeric vector specifying which rows in the Excel file to read.
If NULL, all rows are read.

\item[\code{cols}] A numeric vector specifying which columns in the Excel file to read.
If NULL, all columns are read.

\item[\code{check.names}] logical. If TRUE then the names of the variables in the data frame
are checked to ensure that they are syntactically valid variable names

\item[\code{sep.names}] One character which substitutes blanks in column names. By default, "."

\item[\code{namedRegion}] A named region in the Workbook. If not NULL startRow, rows and cols parameters are ignored.

\item[\code{na.strings}] A character vector of strings which are to be interpreted as NA. Blank cells will be returned as NA.

\item[\code{fillMergedCells}] If TRUE, the value in a merged cell is given to all cells within the merge.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.table
\end{Value}
\HeaderA{read\_xl}{read\_xl}{read.Rul.xl}
%
\begin{Description}
read\_xl is almost same as \code{\LinkA{readxl::read\_excel()}{readxl::read.Rul.excel()}} but it's convenient when not knowing the
sheet names. and the output type is a data.table not a tibble.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
read_xl(
  path,
  sheet = NULL,
  range = NULL,
  col_names = TRUE,
  col_types = NULL,
  na = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = getOption("jaid.guess_max"),
  progress = readxl_progress(),
  .name_repair = "unique"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] Path to the xls/xlsx file.

\item[\code{sheet}] Sheet to read. Either a string (the name of a sheet), or an
integer (the position of the sheet). Ignored if the sheet is specified via
\code{range}. If neither argument specifies the sheet, defaults to the first
sheet.

\item[\code{range}] A cell range to read from, as described in \LinkA{cell-specification}{cell.Rdash.specification}.
Includes typical Excel ranges like "B3:D87", possibly including the sheet
name like "Budget!B2:G14", and more. Interpreted strictly, even if the
range forces the inclusion of leading or trailing empty rows or columns.
Takes precedence over \code{skip}, \code{n\_max} and \code{sheet}.

\item[\code{col\_names}] \code{TRUE} to use the first row as column names, \code{FALSE} to get
default names, or a character vector giving a name for each column. If user
provides \code{col\_types} as a vector, \code{col\_names} can have one entry per
column, i.e. have the same length as \code{col\_types}, or one entry per
unskipped column.

\item[\code{col\_types}] Either \code{NULL} to guess all from the spreadsheet or a
character vector containing one entry per column from these options:
"skip", "guess", "logical", "numeric", "date", "text" or "list". If exactly
one \code{col\_type} is specified, it will be recycled. The content of a cell in
a skipped column is never read and that column will not appear in the data
frame output. A list cell loads a column as a list of length 1 vectors,
which are typed using the type guessing logic from \code{col\_types = NULL}, but
on a cell-by-cell basis.

\item[\code{na}] Character vector of strings to interpret as missing values. By
default, readxl treats blank cells as missing data.

\item[\code{trim\_ws}] Should leading and trailing whitespace be trimmed?

\item[\code{skip}] Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if \code{range} is given.

\item[\code{n\_max}] Maximum number of data rows to read. Trailing empty rows are
automatically skipped, so this is an upper bound on the number of rows in
the returned tibble. Ignored if \code{range} is given.

\item[\code{guess\_max}] Maximum number of data rows to use for guessing column
types.

\item[\code{progress}] Display a progress spinner? By default, the spinner appears
only in an interactive session, outside the context of knitting a document,
and when the call is likely to run for several seconds or more. See
\code{\LinkA{readxl\_progress()}{readxl.Rul.progress()}} for more details.

\item[\code{.name\_repair}] Handling of column names. Passed along to
\code{\LinkA{tibble::as\_tibble()}{tibble::as.Rul.tibble()}}. readxl's default is `.name\_repair = "unique", which
ensures column names are not empty and are unique.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.table
\end{Value}
\HeaderA{regex\_attr}{Matched attributes using regular expressions}{regex.Rul.attr}
%
\begin{Description}
Find matched attributes using regular expressions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
regex_attr(x, name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any objects; e.g, list, columns of a data.frame or data.table

\item[\code{name}] the regular expression attribute names.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
matched attributes' names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# matched attributes using regular expressions
regex_attr(iris, "class|names")

\end{ExampleCode}
\end{Examples}
\HeaderA{regex\_cols}{Find columns using regular expression pattern}{regex.Rul.cols}
%
\begin{Description}
Find columns using regular expression pattern
\end{Description}
%
\begin{Usage}
\begin{verbatim}
regex_cols(df, pattern)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{pattern}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# find columns using regular expression pattern
df <- data.frame(col_a = c(1, 2, 3), col_b = c("A", "B", "C"), col_c = c(4, 5, 6))
regex_cols(df, pattern = c("a|c"))

\end{ExampleCode}
\end{Examples}
\HeaderA{rep\_row}{Data replication function}{rep.Rul.row}
\methaliasA{rep\_row.data.frame}{rep\_row}{rep.Rul.row.data.frame}
\methaliasA{rep\_row.data.table}{rep\_row}{rep.Rul.row.data.table}
\methaliasA{rep\_row.matrix}{rep\_row}{rep.Rul.row.matrix}
%
\begin{Description}
This function is for replicating data rows
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rep_row(x, ...)

## S3 method for class 'matrix'
rep_row(x, ...)

## S3 method for class 'data.frame'
rep_row(x, ...)

## S3 method for class 'data.table'
rep_row(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] matrix, data.frame, data.table

\item[\code{...}] times, each
\end{ldescription}
\end{Arguments}
%
\begin{Value}
matrix, data.frame, data.table.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
rep_row(iris, times = 3)
rep_row(iris, each  = 3)

\end{ExampleCode}
\end{Examples}
\HeaderA{replace\_a\_with\_b}{Replace A with B}{replace.Rul.a.Rul.with.Rul.b}
%
\begin{Description}
Replace string A with string B in a memory-efficient way
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_a_with_b(df, cols, a, b)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns

\item[\code{a}] a string

\item[\code{b}] a string
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
df <- data.table(x = c("A", "A", "C"), y = c("A", "C", "C"))
set_ptr(df)
data.table::address(df)
replace_a_with_b(df, a = "A", b = "B")
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{replace\_empty\_with\_na}{Replace empty with NA}{replace.Rul.empty.Rul.with.Rul.na}
%
\begin{Description}
Replace empty string like "" with NA\_character\_ in a memory-efficient way
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_empty_with_na(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
df <- data.table(x = c("A", "B", ""), y = c(1, NA, 3), z = c("", "E", ""))
set_ptr(df)
data.table::address(df)
replace_empty_with_na(df)
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{replace\_na\_with\_empty}{Replace NA with empty}{replace.Rul.na.Rul.with.Rul.empty}
%
\begin{Description}
Replace NA\_character\_ with "" in a memory-efficient way
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_na_with_empty(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
df <- data.table(x = c("A", "B", NA), y = c(1, NA, 3), z = c(NA, "E", NA))
set_ptr(df)
data.table::address(df)
replace_na_with_empty(df)
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{replace\_na\_with\_zero}{Replace NA with zero}{replace.Rul.na.Rul.with.Rul.zero}
%
\begin{Description}
Replace NA\_integer\_ or NA\_real\_ values with zero in a memory-efficient way
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_na_with_zero(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
df <- data.table(x = c(1, NA, 3), y = c("A", "B", NA), z = c(NA, 5, NA))
set_ptr(df)
data.table::address(df)
replace_na_with_zero(df)
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{replace\_vec\_in\_mat}{Replace vectors in Matrix}{replace.Rul.vec.Rul.in.Rul.mat}
%
\begin{Description}
Replace vectors in Matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_vec_in_mat(mat, col, vec)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a matrix

\item[\code{col}] string names of columns or numeric order numbers of columns

\item[\code{vec}] a vector to be replaced
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
\HeaderA{replace\_zero\_with\_na}{Replace zero with NA}{replace.Rul.zero.Rul.with.Rul.na}
%
\begin{Description}
Replace zero values with NA\_integer\_ or NA\_real\_ in a memory-efficient way
\end{Description}
%
\begin{Usage}
\begin{verbatim}
replace_zero_with_na(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
df <- data.table(x = c(1, 0, 3), y = c("A", "B", NA), z = c(0, 5, 0))
set_ptr(df)
data.table::address(df)
replace_zero_with_na(df)
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{reverse}{Reverse a vector}{reverse}
%
\begin{Description}
Reverse a vector directly.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
reverse(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A reversed vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# reverse a vector
x <- c(1:10)
reverse(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{rm\_cols}{Remove columns}{rm.Rul.cols}
%
\begin{Description}
Remove columns in a memory efficient way.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rm_cols(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] name of columns to remove (like .(x, y), list(x, y))
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# remove columns
data <- mtcars
pryr::address(data)
rm_cols(data, .(mpg, cyl, disp))
pryr::address(data)

\end{ExampleCode}
\end{Examples}
\HeaderA{rm\_punct}{Remove punctuations}{rm.Rul.punct}
%
\begin{Description}
Remove punctuations.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rm_punct(df, cols, pattern = "(?!\\*)[[:punct:]]")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] a string vector specifying columns

\item[\code{pattern}] a string containing a \LinkA{regular expression}{regular expression}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# remove punctuations
## Not run: df <- data.frame(x = c("A3-", "$+_B", "C+_&"), y = c("123", "R&", "4q_++"))
set_ptr(df)
rm_punct(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{rotate}{rotate a matrix}{rotate}
%
\begin{Description}
Rotate a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rotate(x, angle = c(90, 180, 270))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A matrix

\item[\code{angle}] A numeric value specifying rotation angle (90, 180, 270)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A rotation matrix
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# 90 degree rotation
x <- matrix(1:9, nrow = 3)
rotate(x, 90)

# 180 degree rotation
x <- matrix(1:9, nrow = 3)
rotate(x, 180)

# 270 degree rotation
x <- matrix(1:9, nrow = 3)
rotate(x, 270)

\end{ExampleCode}
\end{Examples}
\HeaderA{row\_max}{max, min, sum on each row of a matrix}{row.Rul.max}
\aliasA{row\_min}{row\_max}{row.Rul.min}
\aliasA{row\_sum}{row\_max}{row.Rul.sum}
%
\begin{Description}
Get max, min, sum of values on each row of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
row_max(x)

row_min(x)

row_sum(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of min, max, sum of values on each row of a matrix
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# row max
x <- matrix(c(1:9), nrow = 3)
row_max(x)

# row min
x <- matrix(c(1:9), nrow = 3)
row_min(x)

# row sum
x <- matrix(c(1:9), nrow = 3)
row_sum(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{rowvec}{Change vector into row vector or column vector}{rowvec}
\aliasA{colvec}{rowvec}{colvec}
%
\begin{Description}
Change vector into row vector or column vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rowvec(x)

colvec(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a column vector or row vector.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# change into column vector
rowvec(c(1, 2, 3, 4, 5))
colvec(c(1, 2, 3, 4, 5))

\end{ExampleCode}
\end{Examples}
\HeaderA{scaler}{Scaler}{scaler}
%
\begin{Description}
Scale a numeric vector using min-max, robust or standard method.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
scaler(x, method = c("minmax", "robust", "standard"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a numeric vector

\item[\code{method}] a string specifying a scaling method (minmax, robust, standard)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a scaled vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# create scaled data
set.seed(123)
x <- rnorm(100)
df <- rbind(
  data.frame(method = "Min-max" , x = seq_along(x), y = scaler(x, "minmax")),
  data.frame(method = "Robust"  , x = seq_along(x), y = scaler(x, "robust")),
  data.frame(method = "Standard", x = seq_along(x), y = scaler(x, "standard"))
)
g <- ggshort::ggline(df, x = x, y = y, group = method, color = method) +
  ggplot2::labs(title = "Scaling Method: Min-max vs Robust vs Standard") +
  ggshort::theme_view()
plotly::ggplotly(g)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{seqvec}{List of sequential vectors}{seqvec}
%
\begin{Description}
Generate list of sequential vectors
\end{Description}
%
\begin{Usage}
\begin{verbatim}
seqvec(from, to, by = 1L)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{from}, \code{to}] the starting and (maximal) end vectors of the sequence.

\item[\code{by}] number: increment of the sequence.
\end{ldescription}
\end{Arguments}
\HeaderA{set\_attr}{Set attributes}{set.Rul.attr}
%
\begin{Description}
setattr functions re-exported from \code{data.table}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_attr(x, name, value)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any objects; e.g, list, columns of a data.frame or data.table

\item[\code{name}] the character attribute name.

\item[\code{value}] the value to assign to the attribute or \code{NULL} removes teh attribute, if present.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the changed object (invisibly) for use in compound statements.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# set attributes
## Not run: df <- data.frame(a = 1:3, b = 4:6)
set_attr(df, "flag", TRUE)
attr(df, "flag")
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_attr\_class}{Set matched attributes' class}{set.Rul.attr.Rul.class}
%
\begin{Description}
Set matched attributes' class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_attr_class(x, name, class, regex = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any objects; e.g, list, columns of a data.frame or data.table

\item[\code{name}] the attribute names.

\item[\code{class}] a string specifying class; e.g, c("data.table", "data.frame")

\item[\code{regex}] a logical specifying attributes finding method (a string vector or regular expression),
regex = \code{TRUE} is a default
\end{ldescription}
\end{Arguments}
%
\begin{Value}
matched attributes' names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# set matched attributes' class
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
attr(df, "summary") <- data.frame(a = 4:6, b = c("d", "e", "f"))
attr(df, "summary")
set_attr_class(df, "sum", c("tbl_df", "tbl", "data.frame"), regex = TRUE)
attr(df, "summary")

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_col\_lower}{Change columns from uppercase to lowercase or from lowercase to uppercase}{set.Rul.col.Rul.lower}
\aliasA{set\_col\_upper}{set\_col\_lower}{set.Rul.col.Rul.upper}
%
\begin{Description}
Change columns from uppercase to lowercase or from lowercase to uppercase
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_col_lower(df)

set_col_upper(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Change columns case
df <- mtcars
set_col_upper(df)
set_col_lower(df)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_col\_order}{Fast column reordering of data.table by reference}{set.Rul.col.Rul.order}
%
\begin{Description}
set\_col\_order reorders the columns of data.table, by reference, to the new order provided.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_col_order(df, neworder, before = NULL, after = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.table

\item[\code{neworder}] names of columns of the new column name ordering

\item[\code{before}, \code{after}] If one of them (not both) was provided with a column name or number, neworder will be inserted before or after that column.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# set_col_order
df <- mtcars
set_col_order(df, .(gear, carb), after = mpg)
set_col_order(df, .(gear, carb), after = am)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_dimnames}{Set dimension, row, column names}{set.Rul.dimnames}
\aliasA{set\_colnames}{set\_dimnames}{set.Rul.colnames}
\aliasA{set\_rownames}{set\_dimnames}{set.Rul.rownames}
%
\begin{Description}
Set dimension, row, column names to a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_dimnames(x, dimnames)

set_rownames(x, rownames)

set_colnames(x, colnames)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A matrix

\item[\code{dimnames}, \code{rownames}, \code{colnames}] A list of dimension names\\{}
A vector of row names\\{}
A vector of column names
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# set dimension names
x <- matrix(c(1:9), ncol = 3)
set_dimnames(x, list(c("a", "a", "b"), c("a", "b", "b")))

# set row names
x <- matrix(c(1:9), ncol = 3)
set_rownames(x, c("a", "a", "b"))

# set column names
x <- matrix(c(1:9), ncol = 3)
set_colnames(x, c("a", "b", "b"))

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_dt}{Set data.table function}{set.Rul.dt}
%
\begin{Description}
setDT function re-exported from \code{data.table}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_dt(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values.
\end{Value}
%
\begin{SeeAlso}
\code{\LinkA{data.table::setDT()}{data.table::setDT()}}
\end{SeeAlso}
\HeaderA{set\_labels}{Set labels}{set.Rul.labels}
\aliasA{get\_labels}{set\_labels}{get.Rul.labels}
%
\begin{Description}
Set column labels for a data frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_labels(df, labels, cols)

get_labels(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{labels}] a string vector specifying labels to describe columns

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
# set labels
## Not run: df <- data.frame(Q1 = c(0, 1, 1), Q2 = c(1, 0, 1))
set_labels(df, labels = c("Rainy?", "Umbrella?"))
View(df)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_ptr}{Set external pointer}{set.Rul.ptr}
%
\begin{Description}
Set external pointer
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_ptr(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No return value.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# set pointer
set_ptr(iris)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_stat\_by}{Set statistic by groups}{set.Rul.stat.Rul.by}
%
\begin{Description}
Set statistic column by groups (mainly cumulative function like \code{\LinkA{cumsum()}{cumsum}}, \code{\LinkA{cumprod()}{cumprod}}, \code{\LinkA{cummax()}{cummax}}, \code{\LinkA{cummin()}{cummin}})
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_stat_by(df, group_var, value_var, fun = cumsum, prefix = "c")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{group\_var}] names of columns for grouping

\item[\code{value\_var}] names of columns to be applied for statistics.

\item[\code{fun}] a function applying to columns

\item[\code{prefix}] a new column's perfix string (if the value\_var is "loss", the new column is "closs")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# set statistics by groups
## Not run: 
set_ptr(mtcars)
set_stat_by(mtcars, .(cyl, vs), value_var = hp, fun = cumsum)
mtcars[, c("cyl", "vs", "chp")]
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{set\_tibble}{Set tibble function}{set.Rul.tibble}
%
\begin{Description}
as\_tibble function re-exported from \code{tibble}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_tibble(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values.
\end{Value}
%
\begin{SeeAlso}
\code{\LinkA{tibble::as\_tibble()}{tibble::as.Rul.tibble()}}
\end{SeeAlso}
\HeaderA{setup\_python\_env}{Setup a Python or Miniconda Environment}{setup.Rul.python.Rul.env}
%
\begin{Description}
This function creates a Python or Miniconda environment, installs necessary Python packages,
and configures the environment for use with the \code{reticulate} package. It optionally supports
forced reinstallation of all specified packages.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setup_python_env(
  env_name = "r-reticulate",
  packages = c("numpy", "pandas", "git+https://github.com/seokhoonj/underwriter"),
  use_miniconda = FALSE,
  force_reinstall = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{env\_name}] A character string specifying the name of the environment. For Python-only
environments, this is the path where the virtual environment will be created
(default: \AsIs{\texttt{\textasciitilde{}/.virtualenvs/<env\_name>}}). For Miniconda, this is the name of the Conda environment
(default: \AsIs{\texttt{\textasciitilde{}/.conda/envs/<env\_name>}}).

\item[\code{packages}] A character vector of Python packages to install. This can include both
regular Python packages (e.g., \code{"numpy"}) and Git-based packages (e.g.,
\code{"git+https://github.com/seokhoonj/underwriter"}).

\item[\code{use\_miniconda}] A logical value indicating whether to use Miniconda for environment management.
If \code{TRUE}, Miniconda will be used to create and manage the environment. If \code{FALSE}, a standalone
Python virtual environment (\code{virtualenv}) will be used. Default is \code{FALSE}.

\item[\code{force\_reinstall}] A logical value indicating whether to force the reinstallation of all specified
packages. If \code{TRUE}, all packages will be reinstalled even if they are already installed. Default is \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The function dynamically handles the creation and activation of Python or Miniconda environments
based on the value of \code{use\_miniconda}. It ensures that Python or Miniconda is installed if not
already available and installs the specified packages using \code{pip} or Conda.
\begin{itemize}

\item{} For Python environments, the virtual environment will be created at
\AsIs{\texttt{\textasciitilde{}/.virtualenvs/<env\_name>}}.
\item{} For Miniconda environments, the Conda environment will be created at
\AsIs{\texttt{\textasciitilde{}/.conda/envs/<env\_name>}}.
\item{} If \code{force\_reinstall = TRUE}, all packages will be reinstalled, including those already installed.

\end{itemize}

\end{Details}
%
\begin{Value}
No return value. The function creates and configures the Python or Miniconda environment.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Create a virtual environment and install packages
## Not run: setup_python_env(
  env_name = "r-reticulate",
  packages = c("numpy", "pandas", "git+https://github.com/seokhoonj/underwriter"),
  use_miniconda = FALSE,
  force_reinstall = FALSE
)
## End(Not run)

# Create a Conda environment and force reinstall packages
## Not run: setup_python_env(
  env_name = "r-reticulate",
  packages = c("numpy", "pandas", "git+https://github.com/seokhoonj/underwriter"),
  use_miniconda = TRUE,
  force_reinstall = TRUE
)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{sizeof}{Object size}{sizeof}
%
\begin{Description}
Calculates the object size
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sizeof(x, unit)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] object vector, data.frame, environment and etc

\item[\code{unit}] size unit \code{B}, \code{KB}, \code{MB}, \code{GB} default \code{KB}
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
sizeof(x = sys.frame(), unit = "kb")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{split\_and\_paste\_uni\_str}{Split and paste unique strings}{split.Rul.and.Rul.paste.Rul.uni.Rul.str}
\aliasA{split\_and\_paste\_sort\_uni\_str}{split\_and\_paste\_uni\_str}{split.Rul.and.Rul.paste.Rul.sort.Rul.uni.Rul.str}
%
\begin{Description}
Split and paste unique strings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
split_and_paste_uni_str(x, split = "|")

split_and_paste_sort_uni_str(x, split = "|")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector

\item[\code{split}] a string to use for splitting
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# split and paste unique strings
split_and_paste_uni_str(c("b|a|b", "d|c|d"), split = "|")
split_and_paste_sort_uni_str(c("b|a|b", "d|c|d"), split = "|")

\end{ExampleCode}
\end{Examples}
\HeaderA{split\_str}{Split strings}{split.Rul.str}
%
\begin{Description}
Split strings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
split_str(x, split = "|")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector

\item[\code{split}] a string to use for splitting
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# split strings
split_str(c("a|b|a", "c|d|c"), split = "|")

\end{ExampleCode}
\end{Examples}
\HeaderA{strati\_sampling}{Stratified Sampling}{strati.Rul.sampling}
%
\begin{Description}
Stratified Sampling
\end{Description}
%
\begin{Usage}
\begin{verbatim}
strati_sampling(
  df,
  group_var,
  size,
  replace = TRUE,
  contain0 = FALSE,
  method = c("round", "floor", "ceiling"),
  verbose = TRUE,
  seed = 123
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] data.table object

\item[\code{group\_var}] names of group variables

\item[\code{size}] a positive numeric sampling size. if the size < 0, it's proportion.

\item[\code{replace}] should sampling be with replacement?

\item[\code{contain0}] whether to include a specific group if the group proportion is 0

\item[\code{method}] a rounding method c('round', 'floor', 'ceiling')

\item[\code{verbose}] if \code{TRUE}sampling summary will be shown.

\item[\code{seed}] a single value, interpreted as integer, or NULL
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.table
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
dt <- iris
data.table::setDT(dt)
strati_sampling(dt, size = 0.1)
strati_sampling(dt, group_var = Species, size = 0.1)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{timeit}{Time it}{timeit}
%
\begin{Description}
Time \R{} code expression
\end{Description}
%
\begin{Usage}
\begin{verbatim}
timeit(expr)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{expr}] \R{} code expression
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
# time it
timeit(for (i in 1:1000000) i)

\end{ExampleCode}
\end{Examples}
\HeaderA{to\_a1\_col}{To a A1 format column}{to.Rul.a1.Rul.col}
%
\begin{Description}
Convert a cell or column numeric from R1C1 to A1 format.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
to_a1_col(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A string specifying a cell or a column
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A string
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# convert a cell or column numeric from R1C1 to A1 format.

to_a1_col(1)
to_a1_col(3)
to_a1_col(26)

\end{ExampleCode}
\end{Examples}
\HeaderA{to\_r1c1\_col}{To a R1C1 format column}{to.Rul.r1c1.Rul.col}
%
\begin{Description}
Convert a cell or column string from A1 to R1C1 format.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
to_r1c1_col(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A string specifying a cell or a column
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A numeric
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# convert a cell or column string from A1 to R1C1 format

to_r1c1_col("C33")
to_r1c1_col("ABC")
to_r1c1_col("ABC123")

\end{ExampleCode}
\end{Examples}
\HeaderA{traverse}{Traverse two vectors}{traverse}
%
\begin{Description}
Intersect the elements of two vectors.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
traverse(x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector

\item[\code{y}] A vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A combined vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# traverse two vectors
x <- c(1, 3, 5, 7)
y <- c(2, 4, 6, 8)
traverse(x, y)

\end{ExampleCode}
\end{Examples}
\HeaderA{trim\_ws}{Trim white space}{trim.Rul.ws}
%
\begin{Description}
Trim white space
\end{Description}
%
\begin{Usage}
\begin{verbatim}
trim_ws(df, cols, ws = "[ \t\r\n]")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] a string vector specifying columns

\item[\code{ws}] a white space \LinkA{regular expression}{regular expression}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return values
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: df <- data.frame(x = c(" A", "B ", " C "), y = c(1, 2, 3))
set_ptr(df)
data.table::address(df)
trim_ws(df)
data.table::address(df)
df
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{type}{Class and type information}{type}
%
\begin{Description}
Show class and type information.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
type(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] object vector, data.frame, environment and etc
\end{ldescription}
\end{Arguments}
%
\begin{Value}
class and type information data frame
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
type(cars)

\end{ExampleCode}
\end{Examples}
\HeaderA{unilen}{Length of a unique vector}{unilen}
%
\begin{Description}
Calculate length of a unique vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unilen(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A length of a unique vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# length of unique vector
x <- c(1, 1, 2, 3, 4, 5, 5)
unilen(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{valid\_cols}{Validate columns}{valid.Rul.cols}
%
\begin{Description}
Does the data frame contain all columns?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
valid_cols(df, cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a data.frame

\item[\code{cols}] a string vector specifying columns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# different columns
## Not run: valid_cols(mtcars, c("mpg", "cyl", "disp", "hp", "drat"))

\end{ExampleCode}
\end{Examples}
\HeaderA{view\_data\_image}{View a html data image}{view.Rul.data.Rul.image}
\aliasA{save\_data\_image}{view\_data\_image}{save.Rul.data.Rul.image}
%
\begin{Description}
View a html data image (Viewer in RStudio).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
view_data_image(
  data,
  caption = "Table.1",
  footnote = NULL,
  digits = 2,
  full_width = FALSE,
  html_font = "Comic Sans MS"
)

save_data_image(
  data,
  caption = "Table.1",
  footnote = NULL,
  digits = 2,
  full_width = FALSE,
  html_font = "Comic Sans MS",
  vwidth = 992,
  vheight = 744,
  zoom = 1.5,
  file
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame

\item[\code{caption}] The table caption.

\item[\code{footnote}] A vector of footnote texts, Footnotes here will be labeled with special symbols.
The vector here should not have more than 20 elements.

\item[\code{digits}] Maximum number of digits for numeric columns, passed to round(). This can also be a vector of length ncol(x), to set the
number of digits for individual columns.

\item[\code{full\_width}] A TRUE or FALSE variable controlling whether the HTML table should have the preferable format for
\code{full\_width}. If not specified, a HTML table will have full width by default but this option will be set to \code{FALSE} for a LaTeX table

\item[\code{html\_font}] A string for HTML css font.

\item[\code{vwidth}] Viewport width. This is the width of the browser "window".

\item[\code{vheight}] Viewport height This is the height of the browser "window".

\item[\code{zoom}] A number specifying the zoom factor. A zoom factor of 2 will result in twice as many pixels vertically and horizontally. Note that
using 2 is not exactly the same as taking a screenshot on a HiDPI (Retina) device: it is like increasing the zoom to 200 doubling the
height and width of the browser window. This differs from using a HiDPI device because some web pages load different, higher-
resolution images when they know they will be displayed on a HiDPI device (but using zoom will not report that there is a HiDPI
device).

\item[\code{file}] A file path
\end{ldescription}
\end{Arguments}
%
\begin{Value}
no return value.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# plot a data image
## Not run: 
plot_data_image(head(data), height = .5)
## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{yearmon}{Year month}{yearmon}
%
\begin{Description}
Get an year month from the date.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
yearmon(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a date vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a character vector
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# get year month
x <- as.Date(c("1999-12-31", "2000-01-01"))
yearmon(x)

\end{ExampleCode}
\end{Examples}
\HeaderA{zen2han}{Zenkaku to Hankaku}{zen2han}
%
\begin{Description}
Covert Zenkaku to Hankaku
\end{Description}
%
\begin{Usage}
\begin{verbatim}
zen2han(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a string vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
\HeaderA{zen2han4dat}{Zenkaku to Hankaku for a data frame}{zen2han4dat}
%
\begin{Description}
Covert Zenkaku columns to Hankaku columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
zen2han4dat(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] a string vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a string vector
\end{Value}
\HeaderA{zeros}{Zeros}{zeros}
%
\begin{Description}
Sample matrix containing only zeros
\end{Description}
%
\begin{Usage}
\begin{verbatim}
zeros(dim)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dim}] a numeric vector specifying dimensions
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with zeros
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# zeros
zeros(c(5, 5))

\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
