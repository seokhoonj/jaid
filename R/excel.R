#' Convert Excel column letters to numbers
#'
#' Converts Excel column letters (A, B, C, ..., AA, AB, etc.) to column numbers.
#'
#' @param x String containing Excel cell reference or column letters.
#'
#' @return Numeric column number (A=1, B=2, ..., Z=26, AA=27, etc.)
#'
#' @examples
#' \donttest{
#' # Convert column letters to numbers
#' to_r1c1_col("C33")    # Returns 3 (C = 3rd column)
#' to_r1c1_col("ABC")    # Returns 731 (ABC = 731st column)
#' to_r1c1_col("ABC123") # Returns 731 (extracts ABC only)
#' }
#'
#' @export
to_r1c1_col <- function(x) {
  col_letters <- get_pattern("[A-Z]+", x)
  letters <- strsplit(col_letters, "")[[1L]]
  result <- 0
  for (letter in letters) {
    result <- result * 26 + (match(letter, LETTERS))
  }
  result
}

#' Convert column numbers to Excel letters
#'
#' Converts column numbers to Excel column letters (1=A, 2=B, 27=AA, etc.).
#'
#' @param x Numeric column number.
#'
#' @return String with Excel column letters.
#'
#' @examples
#' \donttest{
#' # Convert column numbers to letters
#' to_a1_col(1)   # Returns "A" (1st column)
#' to_a1_col(3)   # Returns "C" (3rd column)
#' to_a1_col(26)  # Returns "Z" (26th column)
#' to_a1_col(27)  # Returns "AA" (27th column)
#' }
#'
#' @export
to_a1_col <- function(x) {
  if (x <= 26)
    return(LETTERS[x])
  result <- NA_character_
  while (x > 0) {
    x <- x - 1
    result <- paste0(LETTERS[(x %% 26) + 1], result)
    x <- x %/% 26
  }
  result
}


#' Write data to an Excel workbook
#'
#' Write a data.frame or a list of data.frames to an Excel workbook using
#' `openxlsx`. When a list is supplied, each element is written to a
#' separate worksheet. List names are used as sheet names; unnamed elements
#' receive autogenerated names (e.g., "Sheet 1").
#'
#' @param data A data.frame, or a named/unnamed list of data.frames. When a list
#'   is provided, each element is written to its own worksheet.
#' @param file A file path to the target `.xlsx` workbook.
#' @param rc A length-2 integer vector giving the starting row and column
#'   (default `c(1L, 1L)`).
#' @param row_names Logical; whether to include row names.
#' @param overwrite Logical; if `TRUE`, overwrite an existing workbook.
#' @param font_size Numeric font size for the Excel output (default `14`).
#' @param font_name Font family name for the Excel output (default `"Comic Sans MS"`).
#' @param border_colour Border color used by the writing helper (HEX string, e.g., `"#000000"`).
#' @param widths Column widths passed to the writing helper. Either a single
#'   numeric value recycled across columns or a numeric vector per column.
#'
#' @return No return value, called for side effects (saves an Excel file).
#'
#' @examples
#' \dontrun{
#' write_data_xlsx(
#'   list(cars = cars, mtcars = mtcars),
#'   file = "data.xlsx",
#'   rc = c(1L, 1L),
#'   overwrite = TRUE
#' )
#' }
#'
#' @export
write_data_xlsx <- function(data, file, rc = c(1L, 1L), row_names = FALSE,
                            overwrite = FALSE, font_size = 14,
                            font_name = "Comic Sans MS",
                            border_colour = "#000000", widths = 8.43) {
  if (is.data.frame(data))
    data <- list(data)
  if (!file.exists(file)) {
    wb <- openxlsx::createWorkbook()
    sheet_names <- NULL
  } else {
    wb <- openxlsx::loadWorkbook(file)
    sheet_names <- openxlsx::getSheetNames(file)
  }
  data_names <- names(data)
  if (is.null(data_names)) {
    data_names <- sprintf("Sheet %s", seq_along(data))
  } else {
    empty_names <- which(data_names == "" | is.na(data_names))
    if (length(empty_names)) {
      data_names[empty_names] <- sprintf("Sheet %s", seq_along(empty_names))
    }
  }
  names(data) <- data_names
  new_names <- setdiff(data_names, sheet_names)
  lapply(seq_along(new_names), function(x) {
    openxlsx::addWorksheet(wb = wb, sheetName = new_names[[x]], gridLines = FALSE)
  })
  lapply(seq_along(data), function(x) {
    write_data(wb, sheet = names(data)[[x]], data = data[[x]], rc = rc,
               row_names = row_names, font_size = font_size,
               font_name = font_name, border_colour = border_colour,
               widths = widths)
  })
  openxlsx::saveWorkbook(wb = wb, file = file, overwrite = overwrite)
}

#' Save ggplot object(s) to an Excel workbook
#'
#' Save one or more `ggplot` objects to an Excel workbook. A single `ggplot`
#' object can be supplied directly, or multiple plots can be passed in a list.
#' Each plot is written to a separate worksheet.
#'
#' @param plot A `ggplot` object or a named/unnamed list of `ggplot` objects.
#' @param file A file path to the target Excel workbook.
#' @param rc A length-2 integer vector giving the starting row and column
#'   (default is `c(1L, 1L)`).
#' @param width Image width (in inches).
#' @param height Image height (in inches).
#' @param dpi Resolution of the image (dots per inch).
#' @param overwrite Logical; if TRUE, overwrite an existing workbook.
#'
#' @return No return value, called for side effects (saves an Excel file).
#'
#' @examples
#' \dontrun{
#' library(ggplot2)
#'
#' p1 <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
#' p2 <- ggplot(mtcars, aes(hp, qsec)) + geom_point()
#'
#' # Single plot
#' save_plot_xlsx(p1, "single.xlsx")
#'
#' # Multiple plots
#' save_plot_xlsx(list(Scatter1 = p1, Scatter2 = p2), "multi.xlsx")
#' }
#'
save_plot_xlsx <- function(plot, file, rc = c(1L, 1L), width = 12, height = 6,
                           dpi = 300, overwrite = FALSE) {
  if (inherits(plot, "ggplot")) {
    plot <- list(plot)
  } else if (is.list(plot)) {
    if (!all(vapply(plot, function(p) inherits(p, "ggplot"), logical(1L)))) {
      stop("All elements of the list must be ggplot objects.")
    }
  } else {
    stop("`plot` must be a ggplot object or a list of ggplot objects.")
  }

  if (!file.exists(file)) {
    wb <- openxlsx::createWorkbook()
    sheet_names <- NULL
  } else {
    wb <- openxlsx::loadWorkbook(file)
    sheet_names <- openxlsx::getSheetNames(file)
  }
  plot_names <- names(plot)
  if (is.null(plot_names)) {
    plot_names <- sprintf("Sheet %s", seq_along(plots))
  } else {
    plot_len <- length(plot_names[which(plot_names == "")])
    plot_names[which(plot_names == "")] <- sprintf("Sheet %s", seq_along(plot_len))
  }
  names(plots) <- plot_names
  new_names <- setdiff(plot_names, sheet_names)
  lapply(seq_along(new_names), function(x) {
    openxlsx::addWorksheet(wb = wb, sheetName = new_names[[x]], gridLines = FALSE)
  })
  lapply(seq_along(plots), function(x) {
    print(plots[[x]])
    openxlsx::insertPlot(wb, sheet = names(plots)[[x]], width = width,
                         height = height, startRow = rc[1L], startCol = rc[2L],
                         dpi = dpi)
  })
  openxlsx::saveWorkbook(wb = wb, file = file, overwrite = overwrite)
}

#' Save image file(s) to an Excel workbook
#'
#' Save one or more image files (PNG, JPEG, etc.) to an Excel workbook using
#' `openxlsx`. Each image is inserted into a separate worksheet. If names
#' are supplied, they are used as sheet names; otherwise, autogenerated names
#' like "Sheet 1" are used.
#'
#' @param image A file path (character scalar) or a character vector/list of
#'   image file paths.
#' @param file A file path to the target `.xlsx` workbook.
#' @param rc A length-2 integer vector giving the starting row and column
#'   (default `c(1L, 1L)`).
#' @param width Image width (in inches).
#' @param height Image height (in inches).
#' @param dpi Resolution of the image (dots per inch).
#' @param overwrite Logical; if `TRUE`, overwrite an existing workbook.
#'
#' @return No return value, called for side effects (saves an Excel file).
#'
#' @examples
#' \dontrun{
#' save_image_xlsx(c("img1.png", "img2.jpg"), "images.xlsx")
#' }
#'
#' @export
save_image_xlsx <- function(image, file, rc = c(1L, 1L), width = 12,
                            height = 6, dpi = 300, overwrite = FALSE) {
  # normalize to a named character vector of paths
  if (is.list(image)) image <- unlist(image, use.names = TRUE)

  if (!is.character(image) || length(image) < 1L) {
    stop("`image` must be a file path (character scalar) or a character vector/list of paths.")
  }

  # file existence check
  missing_files <- image[!file.exists(image)]
  if (length(missing_files)) {
    stop("File(s) not found: ", paste(shQuote(missing_files), collapse = ", "))
  }
  if (!file.exists(file)) {
    wb <- openxlsx::createWorkbook()
    sheet_names <- NULL
  } else {
    wb <- openxlsx::loadWorkbook(file)
    sheet_names <- openxlsx::getSheetNames(file)
  }

  image_names <- names(image)

  if (is.null(image_names)) {
    image_names <- sprintf("Sheet %s", seq_along(image))
  } else {
    empty_idx <- which(image_names == "" | is.na(image_names))
    if (length(empty_idx)) {
      image_names[empty_idx] <- sprintf("Sheet %s", seq_along(empty_idx))
    }
  }
  names(image) <- image_names

  new_names <- setdiff(image_names, sheet_names)
  lapply(seq_along(new_names), function(x)
    openxlsx::addWorksheet(wb = wb, sheetName = new_names[[x]], gridLines = FALSE)
  )
  lapply(seq_along(image), function(x)
    openxlsx::insertImage(wb, sheet = names(image)[[x]], width = width,
                          height = height, file = image[[x]],
                          startRow = rc[1L], startCol = rc[2L], dpi = dpi)
  )
  openxlsx::saveWorkbook(wb = wb, file = file, overwrite = overwrite)
}

#' Deprecated: data_xlsx()
#'
#' `r lifecycle::badge("deprecated")`
#'
#' Use [write_data_xlsx()] instead.
#'
#' @param ... Additional arguments passed to [write_data_xlsx()].
#'
#' @return No return value, called for side effects.
#'
#' @seealso [write_data_xlsx()]
#'
#' @export
data_xlsx <- function(...) {
  lifecycle::deprecate_warn("0.0.0.9000", "data_xlsx()", "write_data_xlsx()")
  write_data_xlsx(...)
}

#' Deprecated: plot_xlsx()
#'
#' `r lifecycle::badge("deprecated")`
#'
#' Use [save_plot_xlsx()] instead.
#'
#' @param ... Additional arguments passed to [save_plot_xlsx()].
#'
#' @return No return value, called for side effects.
#'
#' @seealso [save_plot_xlsx()]
#'
#' @export
plot_xlsx <- function(...) {
  lifecycle::deprecate_warn("0.0.0.9000", "plot_xlsx()", "save_plot_xlsx()")
  save_plot_xlsx(...)
}

#' Deprecated: image_xlsx()
#'
#' `r lifecycle::badge("deprecated")`
#'
#' Use [save_image_xlsx()] instead.
#'
#' @param ... Additional arguments passed to [save_image_xlsx()].
#'
#' @return No return value, called for side effects.
#'
#' @seealso [save_image_xlsx()]
#'
#' @export
image_xlsx <- function(...) {
  lifecycle::deprecate_warn("0.0.0.9000", "image_xlsx()", "save_image_xlsx()")
  save_image_xlsx(...)
}

# Helper functions --------------------------------------------------------

write_data <- function(wb, sheet, data, rc = c(1L, 1L), row_names = TRUE,
                       font_size = 14, font_name = "Comic Sans MS",
                       border_colour = "#000000", widths = 8.43) {
  header_style1 <- openxlsx::createStyle(
    fontName = font_name,
    fontSize = font_size,
    fontColour = "#000000",
    halign = "center",
    valign = "center",
    fgFill = "#E6E6E7",
    border = "TopRightBottom",
    borderColour = border_colour,
    borderStyle = c("thick", "thin", "double")
  )
  header_style2 <- openxlsx::createStyle(
    fontName = font_name,
    fontSize = font_size,
    fontColour = "#000000",
    halign = "center",
    valign = "center",
    fgFill = "#E6E6E7",
    border = "TopBottom",
    borderColour = border_colour,
    borderStyle = c("thick", "double")
  )
  body_style1 <- openxlsx::createStyle(
    fontName = font_name,
    border = "TopRightBottom",
    borderColour = border_colour
  )
  body_style2 <- openxlsx::createStyle(
    fontName = font_name,
    border = "TopBottom",
    borderColour = border_colour
  )
  footer_style1 <- openxlsx::createStyle(
    fontName = font_name,
    border = "TopRightBottom",
    borderColour = border_colour,
    borderStyle = c("thin", "thin", "thick")
  )
  footer_style2 <- openxlsx::createStyle(
    fontName = font_name,
    border = "TopBottom",
    borderColour = border_colour,
    borderStyle = c("thin", "thick")
  )

  openxlsx::writeData(wb = wb, sheet = sheet, x = data, xy = rev(rc),
                      rowNames = row_names)

  start_cell <- rc
  end_cell   <- start_cell + dim(data)

  srow <- start_cell[1L]
  scol <- start_cell[2L]
  erow <- end_cell[1L]
  ecol <- end_cell[2L]

  if (!row_names) ecol <- ecol - 1

  header_cols  <- scol:ecol
  header_rows1 <- srow
  header_cols1 <- scol:max(ecol - 1, 1)
  header_rows2 <- srow
  header_cols2 <- ecol
  body_rows1   <- (srow + 1):max(erow - 1, 2)
  body_cols1   <- scol:max(ecol - 1, 1)
  body_rows2   <- (srow + 1):max(erow - 1, 2)
  body_cols2   <- ecol
  footer_rows1 <- erow
  footer_cols1 <- scol:max(ecol - 1, 1)
  footer_rows2 <- erow
  footer_cols2 <- ecol

  openxlsx::addStyle(wb, sheet = sheet, header_style1, rows = header_rows1,
                     cols = header_cols1, gridExpand = TRUE)
  openxlsx::addStyle(wb, sheet = sheet, header_style2, rows = header_rows2,
                     cols = header_cols2, gridExpand = TRUE)
  openxlsx::addStyle(wb, sheet = sheet, body_style1, rows = body_rows1,
                     cols = body_cols1, gridExpand = TRUE)
  openxlsx::addStyle(wb, sheet = sheet, body_style2, rows = body_rows2,
                     cols = body_cols2, gridExpand = TRUE)
  openxlsx::addStyle(wb, sheet = sheet, footer_style1, rows = footer_rows1,
                     cols = footer_cols1, gridExpand = TRUE)
  openxlsx::addStyle(wb, sheet = sheet, footer_style2, rows = footer_rows2,
                     cols = footer_cols2, gridExpand = TRUE)

  openxlsx::setColWidths(wb, sheet, cols = header_cols, widths = widths)
}

insert_plot <- function(wb, sheet, plot, rc = c(1L, 1L), width = 12, height = 6,
                        dpi = 300) {
  print(plot)
  openxlsx::insertPlot(wb, sheet = sheet, width = width, height = height,
                       startRow = rc[1L], startCol = rc[2L], dpi = dpi)
}
